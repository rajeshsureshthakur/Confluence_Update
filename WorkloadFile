<!DOCTYPE html>
<html>
<head>
    <!-- Previous styles remain same -->
    <style>
        /* Previous styles */
        .input-section { margin: 10px 0; }
        .calculate-btn { margin: 10px 0; }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 10px 0;
            color: #172B4D;
        }
        th {
            background-color: #F4F5F7;
            font-weight: bold;
            text-align: left;
            border: 1px solid #DFE1E6;
            padding: 7px 10px;
            font-size: 14px;
        }
        td {
            border: 1px solid #DFE1E6;
            padding: 7px 10px;
            font-size: 14px;
        }
        tr:hover { background-color: #F8F9FA; }
        .numeric {
            text-align: right;
            font-family: monospace;
        }
        .warning { color: #DE350B; }
        .suggestion { color: #0747A6; }
    </style>
</head>
<body>
    <!-- Previous HTML structure remains same -->
    <div class="input-section">
        <label>Last Test Results CSV (Transaction Name, Response Time, Pass Count, Fail Count)</label><br>
        <input type="file" id="lastResultsFile" accept=".csv">
    </div>

    <div class="input-section">
        <label>Test Planning Data CSV (Transaction Name, Script Name, SLA, Planned TPH, Previous VUsers, Think Time, Pacing)</label><br>
        <input type="file" id="planningDataFile" accept=".csv">
    </div>

    <div class="calculate-btn">
        <button onclick="calculateVUsers()">Calculate VUsers</button>
    </div>

    <table id="recommendations">
        <tr>
            <th>Script Name</th>
            <th>Current TPH</th>
            <th>Target TPH</th>
            <th>Response Time (avg)</th>
            <th>Think Time</th>
            <th>Pacing</th>
            <th>Current VUsers</th>
            <th>Recommended VUsers</th>
            <th>Current TPH/User</th>
            <th>Suggestions</th>
        </tr>
    </table>

    <script>
        // Previous helper functions remain same
        function processCSVFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result.trim().split('\n').map(row => row.split(',').map(cell => cell.trim())));
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        function calculateWorkload(data, avgResponseTime) {
            try {
                const currentThinkTime = data.totalThinkTime / data.transactionCount;
                const currentIterationTime = avgResponseTime + currentThinkTime + data.pacing;
                const iterationsPerHourPerUser = 3600 / currentIterationTime;
                const currentTphPerUser = data.currentTph / data.currentVUsers;

                let recommendedVUsers = Math.ceil(data.targetTph / currentTphPerUser);
                let adjustedPacing = data.pacing;
                let adjustedThinkTime = currentThinkTime;
                let suggestions = [];

                const vuserChange = ((recommendedVUsers - data.currentVUsers) / data.currentVUsers) * 100;
                
                if (Math.abs(vuserChange) > 30) {
                    const targetTphPerUser = data.targetTph / (data.currentVUsers * 1.3);
                    const requiredIterationTime = 3600 / targetTphPerUser;
                    const currentTime = avgResponseTime + currentThinkTime + data.pacing;
                    const timeReduction = currentTime - requiredIterationTime;

                    if (timeReduction > 0) {
                        if (data.pacing > 5) {
                            const newPacing = Math.max(5, data.pacing - timeReduction/2);
                            adjustedPacing = newPacing;
                            suggestions.push(`Consider reducing pacing from ${data.pacing}s to ${newPacing.toFixed(1)}s`);
                        }
                        
                        if (currentThinkTime > 2) {
                            const newThinkTime = Math.max(2, currentThinkTime - timeReduction/2);
                            adjustedThinkTime = newThinkTime;
                            suggestions.push(`Consider adjusting think time from ${currentThinkTime.toFixed(1)}s to ${newThinkTime.toFixed(1)}s`);
                        }

                        const newIterationTime = avgResponseTime + adjustedThinkTime + adjustedPacing;
                        const newIterationsPerHour = 3600 / newIterationTime;
                        recommendedVUsers = Math.ceil(data.targetTph / newIterationsPerHour);
                    }
                }

                if (avgResponseTime > 2) {
                    suggestions.push(`High response time (${avgResponseTime.toFixed(2)}s) may limit throughput`);
                }

                if (data.targetTph > data.currentTph * 2) {
                    suggestions.push(`Large TPH increase (${data.currentTph.toFixed(1)} â†’ ${data.targetTph}) - consider gradual scaling`);
                }

                return {
                    vusers: recommendedVUsers,
                    pacing: adjustedPacing,
                    thinkTime: adjustedThinkTime,
                    tphPerUser: currentTphPerUser,
                    suggestions: suggestions
                };
            } catch (error) {
                console.error('Calculation error:', error);
                return {
                    vusers: data.currentVUsers,
                    pacing: data.pacing,
                    thinkTime: data.totalThinkTime / data.transactionCount,
                    tphPerUser: data.currentTph / data.currentVUsers,
                    suggestions: ['Error in calculations. Using current values.']
                };
            }
        }

        async function calculateVUsers() {
            const lastResultsFile = document.getElementById('lastResultsFile').files[0];
            const planningDataFile = document.getElementById('planningDataFile').files[0];
            
            if (!lastResultsFile || !planningDataFile) {
                alert('Please select both CSV files');
                return;
            }

            try {
                const lastResults = await processCSVFile(lastResultsFile);
                const planningData = await processCSVFile(planningDataFile);

                // First, create a mapping of transactions to scripts from planning data
                const transactionToScript = {};
                const scriptInfo = {};
                
                planningData.forEach(row => {
                    const [transactionName, scriptName, , plannedTph, vusers, thinkTime, pacing] = row;
                    transactionToScript[transactionName] = scriptName;
                    
                    if (!scriptInfo[scriptName]) {
                        scriptInfo[scriptName] = {
                            totalPlannedTph: 0,
                            vusers: parseInt(vusers),
                            pacing: parseInt(pacing),
                            thinkTime: parseFloat(thinkTime),
                            transactions: new Set()
                        };
                    }
                    scriptInfo[scriptName].totalPlannedTph += parseInt(plannedTph);
                    scriptInfo[scriptName].transactions.add(transactionName);
                });

                // Calculate current TPH for each script based on actual results
                const scriptData = {};
                Object.entries(scriptInfo).forEach(([scriptName, info]) => {
                    scriptData[scriptName] = {
                        currentTph: 0,
                        targetTph: info.totalPlannedTph,
                        currentVUsers: info.vusers,
                        pacing: info.pacing,
                        totalResponseTime: 0,
                        totalThinkTime: 0,
                        transactionCount: 0,
                        transactions: new Set()
                    };
                });

                // Process last results and calculate TPH
                lastResults.forEach(row => {
                    const [transactionName, responseTime, passCount] = row;
                    const scriptName = transactionToScript[transactionName];
                    
                    if (scriptName && scriptData[scriptName]) {
                        const passes = parseInt(passCount);
                        // Add to TPH (divide by 24 to convert daily count to hourly rate)
                        scriptData[scriptName].currentTph += passes / 24;
                        scriptData[scriptName].totalResponseTime += parseFloat(responseTime);
                        scriptData[scriptName].totalThinkTime += scriptInfo[scriptName].thinkTime;
                        scriptData[scriptName].transactionCount++;
                        scriptData[scriptName].transactions.add(transactionName);
                    }
                });

                const recommendations = document.getElementById('recommendations');
                while (recommendations.rows.length > 1) {
                    recommendations.deleteRow(1);
                }

                Object.entries(scriptData).forEach(([scriptName, data]) => {
                    if (data.transactionCount === 0) return;

                    const row = recommendations.insertRow(-1);
                    const avgResponseTime = data.totalResponseTime / data.transactionCount;
                    const recommendation = calculateWorkload(data, avgResponseTime);

                    row.insertCell(0).textContent = scriptName;
                    row.insertCell(1).textContent = data.currentTph.toFixed(2);
                    row.insertCell(2).textContent = data.targetTph;
                    row.insertCell(3).textContent = avgResponseTime.toFixed(2) + 's';
                    row.insertCell(4).textContent = recommendation.thinkTime.toFixed(1) + 's';
                    row.insertCell(5).textContent = recommendation.pacing.toFixed(1) + 's';
                    row.insertCell(6).textContent = data.currentVUsers;
                    row.insertCell(7).textContent = recommendation.vusers;
                    row.insertCell(8).textContent = recommendation.tphPerUser.toFixed(2);
                    row.insertCell(9).textContent = recommendation.suggestions.join('\n');

                    [1,2,3,4,5,6,7,8].forEach(index => {
                        row.cells[index].className = 'numeric';
                    });
                    
                    if (recommendation.suggestions.length > 0) {
                        row.cells[9].className = 'suggestion';
                    }
                });
            } catch (error) {
                alert('Error processing files: ' + error.message);
            }
        }
    </script>
</body>
</html>
